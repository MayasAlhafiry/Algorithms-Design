#include <iostream>
using namespace std;

class MaxHeap { // Define a class/structure for the heap.
private:
    int* values;
    int* priorities;
    int size;  // Maximum size of the array
    int count; // current number of elements actually in the heap

    void heapifyDown(int index) {
        int largest = index;
        int left = 2 * index + 1; // Index of the left child
        int right = 2 * index + 2; // Index of the right child

        if (left < count && priorities[left] > priorities[largest]) // Check if the left child exists and is greater than the current largest
            largest = left;

        if (right < count && priorities[right] > priorities[largest]) // Check if the right child exists and is greater than the current largest
            largest = right;

        if (largest != index) {
            swap(priorities[index], priorities[largest]);
            swap(values[index], values[largest]);
            heapifyDown(largest);
        }
    }

    void heapifyUp(int index) {
        int parent = (index - 1) / 2;
        if (index > 0 && priorities[index] > priorities[parent]) {
            swap(priorities[index], priorities[parent]);
            swap(values[index], values[parent]);
            heapifyUp(parent);
        }
    }

public:
    MaxHeap(int s) { //Constructor
        size = s;          // Set max size
        count = 0;    // Start empty
        values = new int[size];
        priorities = new int[size];
    }


    void insert(int value) {
        insert(value, value);
    }

    void insert(int value, int priority) {
        if (count == size) { // Check if the heap is already full
            cout << "Heap is full" << endl;
            return;
        }
        values[count] = value; // Place the new value at the end of the heap
        priorities[count] = priority;
        heapifyUp(count);
        count++;  // Increase the number of elements in the heap
    }

    int extractMax() {
        if (count == 0) { // Check if the heap is empty
            cout << "Heap is empty" << endl;
            return -1;
        }
        int max = values[0];
        values[0] = values[count - 1];
        priorities[0] = priorities[count - 1];
        count--;
        heapifyDown(0);
        return max;
    }

    int extractMax(int& value, int& priority) {
        if (count == 0) { // Check if the heap is empty
            cout << "Heap is empty" << endl;
            value = -1;
            priority = -1;
            return -1;
        }
        value = values[0];
        priority = priorities[0];
        values[0] = values[count - 1];
        priorities[0] = priorities[count - 1];
        count--;
        heapifyDown(0);
        return value;
    }


    int extractMin() {
        if (count == 0) { // Check if the heap is empty
            cout << "Heap is empty" << endl;
            return -1;
        }
        int minValue = values[0];
        for (int i = 1; i < count; i++) {
            if (values[i] < minValue)
                minValue = values[i];
        }
        count--; // Reduce the heap size because one element is removed
        heapifyDown(0);
        return minValue;
    }

    int extractMin(int& value, int& priority) {
    	//check if empty
        if (count == 0) {
            cout << "Heap is empty" << endl;
            value = -1;
            priority = -1;
            return -1;
        }

        // Find min element , loop through priorities array to find min and getting the index
        int minIndex = 0;
        for (int i = 1; i < count; i++) {
            if (priorities[i] < priorities[minIndex]) {
                minIndex = i;
            }
        }
       // setting value,priority with the min priority and its value
        value = values[minIndex]; 
        priority = priorities[minIndex];
 
        values[minIndex] = values[count - 1]; // move the last element to min position so that min priority is in last leaf
        priorities[minIndex] = priorities[count - 1];
        count--; 

        // Heapify from the position where we removed the element if its last index it will do nothing
        heapifyDown(minIndex);
        heapifyUp(minIndex); // need to heapify up in case we moved a larger element 

        return value;
    }

    bool isEmpty() {
        if (count == 0) {
            return true;
        }
        else {
            return false;
        }
    }

    void display() {
        cout << "Elements: ";
        for (int i = 0; i < count; i++)
            cout << "(" << values[i] << ", " << priorities[i] << ") ";
        cout << endl;
    }


};

class PriorityQueue {
private:
    MaxHeap heap;
    // a dequeue helper
    void dequeueHelper(int& value,int& Priority) {
        if (heap.isEmpty()) {
            cout << "Heap is empty,nothing to remove" << endl;
        }
        heap.extractMax( value, Priority);
    }
    // a peek helper
    void peekHelper(int& value,int& Priority) {
        if (heap.isEmpty()) {
            cout << "Heap is empty,nothing to peek at" << endl;
            return;
        }
        heap.extractMax( value, Priority);
        heap.insert( value, Priority);
    }
public:
	//constuctor
    PriorityQueue(int size) : heap(size) {
        cout << "PriorityQueue is created using heap class" << endl;
    }
    // add the value with the highest Priority to the front
    void enqueue(int value,int Priority ) {
        heap.insert(value,Priority);
    }
    // removed the value with the highest Priority used dequeueHelper
    void dequeue() {
        int value, Priority;
        dequeueHelper(value,Priority);
        cout<<"removed value(used dequeue): "<<value<<" the value priority: "<<Priority<<endl;
    }
    //checking the value with the biggest Priority used peekHelper
    void peek() {
        int value, Priority;
        peekHelper(value,Priority);
        cout<<"largest Priority(used peek): "<<value<<" with priority: "<<Priority<<endl;
    }
    //checks if empty
    bool isEmpty() {
        return heap.isEmpty();
    }
    //display what is inside the PriorityQueue
    void display() {
        heap.display();
    }

};



void heapSort(int arr[], int n) {
    MaxHeap heap(n);
    for (int i = 0; i <n; i++) {
        heap.insert(arr[i], arr[i]);
    }
    for (int i = n-1; i >=0; i--) { // from ent to front, bec the bigger number take bigger priority
        arr[i] = heap.extractMax();
    }
    for (int i = 0; i<n; i++) {
        cout << arr[i] << " ";
    }
}



int main()
{

    cout << "\nHeap sort\n";
    int arr[] = {8, 2, 5, 3, 8, 4, 9, 1};
    heapSort(arr, 8);
    cout << "\n";

    //  MaxHeap
    cout << "\nHeap Max\n";
    MaxHeap heap(8);
    heap.insert(6);
    heap.insert(9);
    heap.insert(5);
    heap.insert(2);
    heap.insert(4);
    heap.insert(0);
    heap.insert(5);

    heap.display();
    int max = heap.extractMax();
    cout << "Extract Max Element: " << max << endl;
    heap.display();

    cout << endl;

    heap.display();
    int min = heap.extractMin();
    cout << "Extract Min Element: " << min << endl;
    heap.display();


    //  MaxHeap
    cout << "\nHeap Max with priority\n";
    MaxHeap heapP(8);
    heapP.insert(6, 4);
    heapP.insert(9, 0);
    heapP.insert(5, 2);
    heapP.insert(2, 2);
    heapP.insert(4, 5);
    heapP.insert(0, 3);
    heapP.insert(5, 6);

    heapP.display();
    int maxP, maxV;
    heapP.extractMax(maxV, maxP);
    cout << "Extract Max Priority Element: " << "(" << maxV << ", "<< maxP << ")" << endl;
    heapP.display();

    cout << endl;

    heapP.display();
    int minP, minV;
    heapP.extractMin(minV, minP);
    cout << "Extract Min Priority Element: " << "(" << minV << ", "<< minP << ")" << endl;
    heapP.display();

    //PriorityQueue test cases
    cout<<"priority queue test cases:"<<endl;
    PriorityQueue pq(10);
    pq.enqueue(40, 2);
    pq.enqueue(30, 5);
    pq.enqueue(60, 1);
    pq.enqueue(20, 3);
    pq.display();
    pq.peek();
    pq.display();
    pq.dequeue();
    pq.display();



return 0;
}
